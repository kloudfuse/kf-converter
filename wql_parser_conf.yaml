NoopFuncs:
  - interpolate
  - bestEffort
  - default
  - last
  - limit
SpaceAggrVars:
  "${sum}" : sum
TimeAggrVars:
FunctionVars:
  "${interpolate}" : "interpolate"
AdditionalMetricChars: "[]^\\/~"
Sanitize:
  "\t" : " "
DefaultTimerange: "1h"
Operators:
  "gt" : ">"
  "gte" : ">="
  "lt" : "<"
  "lte" : "<="
RangeTranslations:
  "default" : "5m"  # Default is translated to 5m
  "vw" : "4h" # view window to time window translation - assuming 1vw = 4h here.
  "bw" : "2h" # bucket window - defaulting to 2 hours.
UnitTranslations:
  # "M" : "000000" # M is translated to six zeros (1,000,000)
AddAggrOverTime: ""
CustomTagRules:
  - Tagname: source
    Wildcard: false
    Default: TBD
    Description: "wildcard is not allowed for source tags value"
    # 'split' policy will split the 'source' label and values based on the following splitrules.
    Policy: split
    # Following splitrule mean that 'source' label will be split to the list of specified tagnames and for each of those tags, if the 'lookup' value is found in the original value then it is replaced with 'use' value
    Splitrules:
      - Tagname: dc_physical
        Lookup: pdx
        Use: us-west-2
      - Tagname: env_physical
        Lookup: eng
        Use: eng
  - Tagname: some_name
    Policy: drop # This policy will drop 'some_name tag and value from the generated query.
    Wildcard: false
    Default: TBD
    Description: "wildcard is not allowed for some_name tag value"
  - Tagname: some_other_name
    Policy: replace_with_default  # This policy will add 'some_other_name="TBD" as label because TBD is the default value for this tag
    Wildcard: false
    Default: TBD
    Description: "wildcard is not allowed for some_other_name tag value"
AdditionalDescriptions:
  - Name: if
    Type: function
    Description: ""
  - Name: orElse
    Type: function
    Description: "For orElse consider using something like https://grafana.com/docs/grafana/latest/panels-visualizations/configure-value-mappings/ in the relevant panel if it fits the need of this query."
  - Name: alert
    Type: metric_name
    Description: "'alerts' in prom should be looked up using count(ALERTS{owner=“<namespace>”})) instead."
# Metric name translations change the metric name based on following map.
# for example, based on the following setting, aws.ec2.CPUUtilization is
# converted to aws.ec2.cpuutilization in the parsing phase. This is applied
# even before translation of chars such as '.' to '_' etc.
MetricNameTranslations:
  METRICS_PUBLISHER_queue: metrics_publisher_queue
# metrics under ExpandAvgMetricNames are treated as average for which
# the conversion/parsing will break it down to _sum/_count metrics. For example,
# based on the following config, aws.ec2.CPUUtilization is first translated
# to aws.ec2.cpuutilzation (because this metric is also listed in above translation
# map) and then it's broken into aws_ec2_cpuutilization_sum/aws_ec2_cpuutilization_count
# so, an expression such as avg:aws.ec2.my.metric{label="val"} by {foo} will get converted into
# avg by (foo)((aws_ec2_my_metric_sum{label="val"})/(aws_ec2_my_metric_count{label="val"}))
# Note that the same filtering is applied to both metrics. Any space or time aggregate or grouping
# is then applied to the expanded conversion.
ExpandAvgMetricNames:
  MetricNames:
  AggregateNames:
    avg: expand
# Following mapping contains the name of the key/label to be used for a given tag variable.
# if a tag variable is not listed here and is encountered in a query, then it is translated as is.
# example: avg:foo{$level} will convert to avg(foo{level_name=~"$level"}), but
#          avg:foo{$someothervar} will convert to avg(foo{$someothervar}) (since $someothervar isn't
# in the following list, it is not expanded.)
VarsMapping:
  DC: dc_physical
DropVariablesWithoutMapping: false